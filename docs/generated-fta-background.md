# FTA (Fast TypeScript Analyzer) Overview and ESLint Plugin Integration

## What is FTA and How It Works

- **Fast Static Analysis:** FTA is a static analysis tool for TypeScript (and JavaScript) code, written in Rust ([Fast TypeScript Analyzer – FTA](https://ftaproject.dev/#:~:text=FTA%20,you%20may%20want%20to%20address)). It focuses on capturing static information about code to reveal complexity and maintainability issues.
- **AST-Based Metrics:** FTA uses the SWC parser to quickly generate an AST of the code, then runs various analytical routines over it ([Fast TypeScript Analyzer – FTA](https://ftaproject.dev/#:~:text=maintainability%20issues%20that%20you%20may,want%20to%20address)). It computes multiple metrics that indicate code complexity.
- **Key Complexity Metrics:** FTA calculates **Halstead complexity measures** (based on unique/total operators and operands), **cyclomatic complexity** (number of independent paths through the code), and lines of code, among others ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=To%20this%20end%2C%20under%20the,to%20produce%204%20key%20metrics)). These are aggregated into a single **FTA Score** – a normalized metric indicating overall maintainability (lower score means simpler, more maintainable code) ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=FTA%20Score%20Assessment%20,Considered%20maintainable)).
- **Per-File Analysis:** FTA analyzes code on a per-file basis. For each file, it produces an FTA Score and a qualitative assessment (e.g. “OK”, “Could be better”, “Needs improvement”) based on that score ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=FTA%20Score%20Assessment%20,Considered%20maintainable)). This helps identify files that are large or complex and may need refactoring.
- **High Performance:** As the name suggests, FTA is extremely fast. It leverages Rust’s performance and SWC’s speed – on typical hardware it can analyze up to ~1600 files per second ([Fast TypeScript Analyzer – FTA](https://ftaproject.dev/#:~:text=%E2%9A%A1)). This makes it feasible to run FTA even on large codebases without significant overhead.

## FTA Usage and API (for Integration)

- **Available Distributions:** FTA is available as a CLI tool, an in-browser WebAssembly package, and a Rust library. The **`fta-cli`** npm package is the recommended way to use FTA via Node (e.g. in CI or build tools), while **`fta-wasm`** is used for running FTA in browsers (the official web playground), and a Rust crate is provided for low-level use ([Getting Started – FTA](https://ftaproject.dev/docs/getting-started#:~:text=FTA%20is%20distributed%20in%20several,ways)). For an ESLint plugin (which runs in Node), `fta-cli` is the appropriate choice ([Getting Started – FTA](https://ftaproject.dev/docs/getting-started#:~:text=%2A%20The%20%60fta,internal%20or%20advanced%20usage%20only)).
- **Programmatic API (`runFta`):** The `fta-cli` package exposes a function `runFta` that you can call from JavaScript/TypeScript. For example:

  ```js
  import { runFta } from "fta-cli";
  const output = runFta("path/to/project", { json: true });
  ```

  This will run FTA on the specified project path and return the results in JSON format ([Getting Started – FTA](https://ftaproject.dev/docs/getting-started#:~:text=%2F%2F%20Print%20the%20standard%20ascii,path%2Fto%2Fproject)). (There is also a CommonJS require syntax available. ([Getting Started – FTA](https://ftaproject.dev/docs/getting-started#:~:text=You%20can%20also%20call%20%60fta,from%20code)))

- **Input Expectations:** FTA expects a directory path (the “project root”) as input and will automatically find and analyze all `.ts`/`.tsx` and `.js` files under that directory ([Configuration – FTA](https://ftaproject.dev/docs/configuration#:~:text=FTA%20expects%20to%20be%20provided,JavaScript%20code%20within%20that%20directory)). By default it recurses through subfolders looking for code. In practice, this means if you point `runFta` at a folder (e.g., your project or src directory), it will analyze every TypeScript/JavaScript file inside.
- **JSON Output:** Using the `{ json: true }` option (or the `--json` flag in the CLI) makes FTA return a JSON representation of the results instead of a printed table ([GitHub - sgb-io/fta: Rust-based static analysis for TypeScript projects](https://github.com/sgb-io/fta#:~:text=%2F%2F%20Print%20the%20standard%20ascii,path%2Fto%2Fproject)). The JSON includes an entry for each file analyzed. Each file’s data contains fields like the file name, `cyclo` (cyclomatic complexity count), a `halstead` object (with details such as `uniq_operators`, `uniq_operands`, `total_operators`, `total_operands`, etc.), the `line_count`, the computed `fta_score`, and an `assessment` string ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=The%20full%20metrics%20available%20for,each%20file)) ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=,)). This rich output is what an ESLint plugin would consume to decide if a file violates complexity thresholds.
- **Default vs Custom Config:** FTA’s CLI supports various configuration options (via an `fta.json` or CLI flags) – for example, you can set an output limit, include/exclude certain files, or define a score threshold (“score cap”) at which the tool should fail ([Configuration – FTA](https://ftaproject.dev/docs/configuration#:~:text=CLI%20arguments)) ([Configuration – FTA](https://ftaproject.dev/docs/configuration#:~:text=)). By default, though, if you call `runFta(path, { json: true })`, it will use default settings and produce JSON for all files under the path.

## Example: Using FTA in a TypeScript ESLint Plugin

- **Setup:** In an ESLint plugin (written in TypeScript), you would add `fta-cli` as a dependency (e.g. `npm install fta-cli`). This gives you access to FTA’s `runFta` function in your plugin code. For instance, you might import it at the top of your ESLint rule file: `import { runFta } from "fta-cli";` ([Getting Started – FTA](https://ftaproject.dev/docs/getting-started#:~:text=You%20can%20also%20call%20%60fta,from%20code)).
- **Invoking FTA per File:** Within your ESLint rule, you can call FTA on the file being linted. For example, in the rule’s logic (e.g. triggered on the Program node or at end of file processing), do something like: `const resultJson = runFta(currentFilePath, { json: true });`. This will run FTA analysis on the given file (or that file’s directory) and return JSON output. Typically, you’d parse `resultJson` (if it’s a JSON string) to an object. The result will include the metrics for the file – likely as a single-element array if only one file was analyzed.
- **Using the Results:** Once you have FTA’s metrics for the file, you can decide how to surface them as lint feedback. For example, you might retrieve the `fta_score` from the result and compare it against a threshold. If the score is above your threshold (meaning the file is too complex), you can report an ESLint warning or error. You could also incorporate other metrics (cyclomatic or Halstead sub-metrics) if desired. All the data (Halstead counts, cyclomatic complexity, etc.) is available in the JSON ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=The%20full%20metrics%20available%20for,each%20file)) ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=,)).
- **Reporting a Lint Issue:** ESLint allows rules to report problems with a message and a location. Since FTA’s output is file-level, the rule might report the issue against the entire file (for instance, at line 1, column 0, or no specific line). The message could be along the lines of: “FTA Complexity score **X** exceeds the allowed limit of **Y** – consider refactoring this file.” This way, when a developer opens the file in an editor, they see a lint warning that the file as a whole is considered too complex by FTA’s standards.
- **TypeScript Integration:** Because the ESLint plugin itself is in TypeScript, you can define types for FTA’s output (perhaps based on the `AnalyzedFile` shape that FTA produces) for better type safety. The `fta-cli` may not come with TypeScript definitions for the JSON structure, but you can infer them from the documentation or output (fields like `fta_score: number`, `cyclo: number`, `halstead: { uniq_operators: number, ... }`, etc.). This makes it easier to work with the results in your plugin code.

## Considerations for ESLint Plugin Development

- **Per-File vs. Whole-Project Analysis:** FTA is designed to analyze an entire project in one run (you point it at a directory and it processes all files) ([Configuration – FTA](https://ftaproject.dev/docs/configuration#:~:text=FTA%20expects%20to%20be%20provided,JavaScript%20code%20within%20that%20directory)). For an ESLint plugin, you have a choice: run FTA **once for the whole project** vs. **for each file individually**.
  - _Whole Project in One Go:_ You could run `runFta` on the project’s root at the start of the lint run and get metrics for all files at once. This is efficient (FTA can analyze many files very quickly in a batch) and avoids repeated work. However, ESLint’s API doesn’t easily provide a hook to run something once and share the results with all rule instances (it operates file-by-file). You’d need to coordinate a global analysis (perhaps in an ESLint `context.getSourceCode()` or via a custom ESLint CLI wrapper), which is non-trivial.
  - _Per-File Calls:_ The simpler approach is to call `runFta` for each file as it’s linted. This means FTA will parse and analyze that file on demand. Thanks to FTA’s speed, this is quite feasible – even on a per-file basis – without significant slowdown. (FTA’s analysis of a single file should take only a few milliseconds in most cases, given it can handle thousands per second ([Fast TypeScript Analyzer – FTA](https://ftaproject.dev/#:~:text=%E2%9A%A1)).) The downside is a bit of redundant overhead (each file is parsed by ESLint’s parser _and_ again by FTA’s parser), but in practice the performance impact should be minor and the implementation is much simpler.
- **Performance Impact:** Because FTA is built in efficient Rust code and uses a high-performance parser, integrating it into ESLint should not be a bottleneck. Even if invoked separately for each file, FTA will likely finish long before typical lint rules that do complex AST analysis in JavaScript. The biggest cost is parsing the file, which FTA does very quickly via SWC. In summary, from a performance standpoint, using FTA in an ESLint rule is viable – it’s designed for speed and can handle large codebases with minimal delay ([Fast TypeScript Analyzer – FTA](https://ftaproject.dev/#:~:text=%E2%9A%A1)).
- **Result Granularity (File-Level):** One important consideration is that FTA’s output is **file-level**, not pinpointed to specific lines or code segments. The metrics (Halstead, cyclomatic, etc.) are aggregated for the entire file. This means an ESLint rule using FTA can really only flag a **whole file** for being too complex; it cannot directly highlight “this function is too complex” or “this line is problematic,” because FTA doesn’t break down the complexity by line (at least in the current version) ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=first)). Developers seeing the lint message will know that the file overall is considered complex, but the onus is on them to inspect the file and identify the difficult parts. This is a different style of feedback compared to typical ESLint rules, which often pinpoint a line of code – but it’s still valuable information.
- **Reporting Location:** Given the above, the plugin might report the issue at a neutral location in the file – for example, at the top of the file or on the file name itself (some ESLint reporters show file-level errors without a line). This is a cosmetic detail, but worth noting: since we can’t tie the complexity warning to a specific node in the AST, we treat it as a file-scoped warning. (Another approach could be to report on the largest function or last line of the file as a heuristic, but that’s optional and not directly provided by FTA’s data.)
- **Configurable Thresholds:** You’ll likely want to make the rule configurable – teams may have different opinions on what an acceptable FTA score is. FTA itself has a concept of `score_cap` (a maximum allowed score) that can be set in its config; if any file exceeds it, the CLI will exit with an error ([Configuration – FTA](https://ftaproject.dev/docs/configuration#:~:text=)). In an ESLint plugin context, you can mimic this. For example, allow users to configure a numeric threshold (say, 60 by default). The rule will compare each file’s `fta_score` to that threshold. If the score is higher (meaning the file is more complex than allowed), the rule reports a problem. This way, the rule essentially wraps FTA’s logic in an ESLint-friendly form, producing a pass/fail outcome per file based on the complexity score ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Another%20school%20of%20thought%20is,file%20basis)). You might also expose other options (like whether to include comments in analysis, which is an FTA setting, or whether to use different metrics), but the score threshold is the primary lever.
- **Handling FTA Output:** The `runFta` function currently returns a result that may need parsing. According to discussions, it returns a JSON string when `{ json: true }` is used (or a formatted text table if not in JSON mode) ([Expose all CLI options to the npm library · Issue #173 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/173#:~:text=)). So, in your plugin code, be prepared to do `const data = JSON.parse(output)` (if it’s a string). Once parsed, you get an array of file analysis objects. You’ll need to find the object corresponding to the current file. If you ran `runFta` on just that file or its folder, it might be the first element. If you ran it on the whole project, you’d search the array for the entry with matching file path. Ensuring you correctly map the results to files is important for accuracy.
- **Comparisons to Other Solutions:** It’s helpful to note why one would use FTA in ESLint instead of existing rules. ESLint does have a built-in `complexity` rule, but that focuses on cyclomatic complexity per function. Other tools like SonarJS provide an ESLint plugin for code quality which can flag code smells and complexity, but they come with large dependencies and can be heavy to run ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Covering%20static%20analysis%20of%20JS,that%20needs%20it%20the%20most)). FTA offers a lightweight alternative – since it’s pre-compiled to native code or WASM, the overhead in Node is small. Integrating FTA gives a broad picture of code complexity with minimal impact on your ESLint run, and without requiring a full analysis suite or server. It essentially brings a dash of the capabilities of tools like SonarQube or Plato directly into your ESLint workflow, focused on maintainability metrics.

## Insights from GitHub Issue #193 (ESLint Integration Discussion)

The idea of creating an ESLint plugin for FTA has been openly discussed by the FTA maintainers and community. Here are key insights from [GitHub issue #193](https://github.com/sgb-io/fta/issues/193), which was about considering an ESLint integration:

- **File-Wide Warnings vs. Line Highlights:** A user suggested using FTA as an ESLint rule to warn about files that exceed certain complexity metrics. The maintainer responded that one challenge is the nature of Halstead complexity – it’s a property of the entire file, so “it doesn't really make sense to say 'there is an error here' at a specific piece of code” based on that metric ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=first)). In other words, FTA can tell you a file is complex, but not exactly which part of the file is the culprit, at least not with the current data.
- **Approach 1 – Whole-File Thresholds:** Because of the above, the immediate way to integrate is to treat the _file_ as the unit of linting. The maintainer suggested an ESLint plugin could simply wrap FTA’s CLI and leverage something like the `score_cap` idea: if a file’s FTA score breaches a certain threshold, ESLint would flag that file ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Another%20school%20of%20thought%20is,file%20basis)). This aligns with how you might use FTA in CI – failing the build if complexity is too high – but instead it would surface in the developer’s editor as an ESLint error or warning. This approach gives a clear pass/fail signal per file.
- **Approach 2 – Highlighting “Complexity Clusters”:** A more advanced (future) idea is to make FTA capable of identifying _where_ complexity is concentrated. In the issue discussion, they talk about possibly extending FTA to capture complexity per line of code (or per AST node) by modifying the analyzer to record metrics for each line ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=The%20answer%20to%20this%20could,line%20number.%20Something%20like%20this)). If FTA provided, say, a map of line numbers to some complexity score, an ESLint plugin could use that to highlight specific functions or lines that are especially complex. The user and maintainer agreed that this would be more useful, allowing “clustered complexity warnings” in an ESLint context (e.g. flagging a particular function that is doing too much) ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=I%20believe%20you%20are%20right%2C,a%20bit%20of%20contextual%20tuning)). The maintainer even sketched out a potential data structure for per-line complexity in the Rust code and noted that exposing such `per_line_data` **“could be wired in to ESLint”** to pinpoint issues ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Then%2C%20in%20theory%2C%20exposing%20,be%20wired%20in%20to%20ESLint)). However, this capability does **not yet exist** in FTA – it’s a hypothetical enhancement.
- **Current State:** As of the latest discussion, the consensus is that an ESLint plugin would initially have to use the whole-file approach. This means the ESLint rule would treat a file as “failing” if it’s too complex overall, without granular locations. While this is somewhat coarse, it still provides value by directing attention to files that likely need refactoring. The issue’s author noted that even a file-level complexity warning can be useful, especially as a starting point for new projects, though in a large legacy codebase it might just call out many files without pinpointing fixes ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Loading)) ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=I%27m%20not%20sure%20I%20can,tool%20would%20become%20very%20popular)).
- **Implications for Development:** If you proceed to develop the ESLint plugin now, you’ll implement the file-level checks (threshold on FTA score or related metrics). It’s wise to design the rule in a way that could later incorporate finer-grained data if FTA exposes it. For example, you might structure your code to handle multiple findings per file (in case later you get line-specific info). But until FTA adds that, your plugin will likely output at most one finding per file (or perhaps separate findings if you decide to have different rules for different metrics, like one for excessive cyclomatic complexity and another for Halstead “volume”, etc., using FTA’s data).
- **Usefulness and Popularity:** The discussion in issue #193 shows there’s interest in this integration. The user who opened the issue mentioned they “have no doubt that an ESLint plugin implementing this tool would become very popular” ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=I%27m%20not%20sure%20I%20can,tool%20would%20become%20very%20popular)). The maintainer also showed enthusiasm and gave guidance on how it might work. This suggests that wrapping FTA in an ESLint plugin is a welcomed idea, and if done well, could attract many users who want quick feedback on code complexity in their editors. It fills a gap between heavyweight analysis tools and lightweight lint rules, by providing fast, research-backed complexity metrics in a developer-friendly format ([Scoring – FTA](https://ftaproject.dev/docs/scoring#:~:text=The%20goal%20of%20FTA%20is,code%20that%20supports%20refactoring%20decisions)).

In summary, **FTA** provides a fast, robust way to gauge code complexity and maintainability. Integrating it into an **ESLint plugin** involves calling its analysis on each file (or project) and translating the results into lint feedback. Key things to focus on are managing the analysis calls efficiently, choosing appropriate thresholds for warnings/errors, and clearly communicating the results to developers (since the feedback is at a high level per file). The GitHub discussion indicates that while pinpointing exact code issues is limited right now, even file-level alerts for complex code would be valuable – and there’s potential for more granular enhancements in the future. With these insights, a developer can proceed to build an ESLint plugin that wraps FTA, bringing its complexity scoring right into the development workflow. ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=first)) ([Consider ESLint integration? · Issue #193 · sgb-io/fta · GitHub](https://github.com/sgb-io/fta/issues/193#:~:text=Another%20school%20of%20thought%20is,file%20basis))
